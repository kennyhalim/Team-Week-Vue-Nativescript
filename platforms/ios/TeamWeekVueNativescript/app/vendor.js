(global["webpackJsonp"] = global["webpackJsonp"] || []).push([["vendor"],{

/***/ "../node_modules/css-loader/index.js?!../node_modules/nativescript-theme-core/css/core.light.css":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("../node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "/*!\n * NativeScript Theme v1.0.4 (https://nativescript.org)\n * Copyright 2016-2016 The Theme Authors\n * Copyright 2016-2016 Telerik\n * Licensed under MIT (https://github.com/NativeScript/theme/blob/master/LICENSE)\n */.c-white{color:#fff}.c-bg-white{background-color:#fff}.c-black{color:#000}.c-bg-black{background-color:#000}.c-aqua{color:#00caab}.c-bg-aqua{background-color:#00caab}.c-blue{color:#3d5afe}.c-bg-blue{background-color:#3d5afe}.c-charcoal{color:#303030}.c-bg-charcoal{background-color:#303030}.c-brown{color:#795548}.c-bg-brown{background-color:#795548}.c-forest{color:#006968}.c-bg-forest{background-color:#006968}.c-grey{color:#e0e0e0}.c-bg-grey{background-color:#e0e0e0}.c-grey-light{color:#bababa}.c-bg-grey-light{background-color:#bababa}.c-grey-dark{color:#5c687c}.c-bg-grey-dark{background-color:#5c687c}.c-purple{color:#8130ff}.c-bg-purple{background-color:#8130ff}.c-lemon{color:#ffea00}.c-bg-lemon{background-color:#ffea00}.c-lime{color:#aee406}.c-bg-lime{background-color:#aee406}.c-orange{color:#f57c00}.c-bg-orange{background-color:#f57c00}.c-ruby{color:#ff1744}.c-bg-ruby{background-color:#ff1744}.c-sky{color:#30bcff}.c-bg-sky{background-color:#30bcff}.w-full{width:100%}.w-100{width:100}.h-full{height:100%}.h-100{height:100}.m-0{margin:0}.m-t-0{margin-top:0}.m-r-0{margin-right:0}.m-b-0{margin-bottom:0}.m-l-0{margin-left:0}.m-x-0{margin-right:0;margin-left:0}.m-y-0{margin-top:0;margin-bottom:0}.m-2{margin:2}.m-t-2{margin-top:2}.m-r-2{margin-right:2}.m-b-2{margin-bottom:2}.m-l-2{margin-left:2}.m-x-2{margin-right:2;margin-left:2}.m-y-2{margin-top:2;margin-bottom:2}.m-4{margin:4}.m-t-4{margin-top:4}.m-r-4{margin-right:4}.m-b-4{margin-bottom:4}.m-l-4{margin-left:4}.m-x-4{margin-right:4;margin-left:4}.m-y-4{margin-top:4;margin-bottom:4}.m-5{margin:5}.m-t-5{margin-top:5}.m-r-5{margin-right:5}.m-b-5{margin-bottom:5}.m-l-5{margin-left:5}.m-x-5{margin-right:5;margin-left:5}.m-y-5{margin-top:5;margin-bottom:5}.m-8{margin:8}.m-t-8{margin-top:8}.m-r-8{margin-right:8}.m-b-8{margin-bottom:8}.m-l-8{margin-left:8}.m-x-8{margin-right:8;margin-left:8}.m-y-8{margin-top:8;margin-bottom:8}.m-10{margin:10}.m-t-10{margin-top:10}.m-r-10{margin-right:10}.m-b-10{margin-bottom:10}.m-l-10{margin-left:10}.m-x-10{margin-right:10;margin-left:10}.m-y-10{margin-top:10;margin-bottom:10}.m-12{margin:12}.m-t-12{margin-top:12}.m-r-12{margin-right:12}.m-b-12{margin-bottom:12}.m-l-12{margin-left:12}.m-x-12{margin-right:12;margin-left:12}.m-y-12{margin-top:12;margin-bottom:12}.m-15{margin:15}.m-t-15{margin-top:15}.m-r-15{margin-right:15}.m-b-15{margin-bottom:15}.m-l-15{margin-left:15}.m-x-15{margin-right:15;margin-left:15}.m-y-15{margin-top:15;margin-bottom:15}.m-16{margin:16}.m-t-16{margin-top:16}.m-r-16{margin-right:16}.m-b-16{margin-bottom:16}.m-l-16{margin-left:16}.m-x-16{margin-right:16;margin-left:16}.m-y-16{margin-top:16;margin-bottom:16}.m-20{margin:20}.m-t-20{margin-top:20}.m-r-20{margin-right:20}.m-b-20{margin-bottom:20}.m-l-20{margin-left:20}.m-x-20{margin-right:20;margin-left:20}.m-y-20{margin-top:20;margin-bottom:20}.m-24{margin:24}.m-t-24{margin-top:24}.m-r-24{margin-right:24}.m-b-24{margin-bottom:24}.m-l-24{margin-left:24}.m-x-24{margin-right:24;margin-left:24}.m-y-24{margin-top:24;margin-bottom:24}.m-25{margin:25}.m-t-25{margin-top:25}.m-r-25{margin-right:25}.m-b-25{margin-bottom:25}.m-l-25{margin-left:25}.m-x-25{margin-right:25;margin-left:25}.m-y-25{margin-top:25;margin-bottom:25}.m-28{margin:28}.m-t-28{margin-top:28}.m-r-28{margin-right:28}.m-b-28{margin-bottom:28}.m-l-28{margin-left:28}.m-x-28{margin-right:28;margin-left:28}.m-y-28{margin-top:28;margin-bottom:28}.m-30{margin:30}.m-t-30{margin-top:30}.m-r-30{margin-right:30}.m-b-30{margin-bottom:30}.m-l-30{margin-left:30}.m-x-30{margin-right:30;margin-left:30}.m-y-30{margin-top:30;margin-bottom:30}.p-0{padding:0}.p-t-0{padding-top:0}.p-r-0{padding-right:0}.p-b-0{padding-bottom:0}.p-l-0{padding-left:0}.p-x-0{padding-right:0;padding-left:0}.p-y-0{padding-top:0;padding-bottom:0}.p-2{padding:2}.p-t-2{padding-top:2}.p-r-2{padding-right:2}.p-b-2{padding-bottom:2}.p-l-2{padding-left:2}.p-x-2{padding-right:2;padding-left:2}.p-y-2{padding-top:2;padding-bottom:2}.p-4{padding:4}.p-t-4{padding-top:4}.p-r-4{padding-right:4}.p-b-4{padding-bottom:4}.p-l-4{padding-left:4}.p-x-4{padding-right:4;padding-left:4}.p-y-4{padding-top:4;padding-bottom:4}.p-5{padding:5}.p-t-5{padding-top:5}.p-r-5{padding-right:5}.p-b-5{padding-bottom:5}.p-l-5{padding-left:5}.p-x-5{padding-right:5;padding-left:5}.p-y-5{padding-top:5;padding-bottom:5}.p-8{padding:8}.p-t-8{padding-top:8}.p-r-8{padding-right:8}.p-b-8{padding-bottom:8}.p-l-8{padding-left:8}.p-x-8{padding-right:8;padding-left:8}.p-y-8{padding-top:8;padding-bottom:8}.p-10{padding:10}.p-t-10{padding-top:10}.p-r-10{padding-right:10}.p-b-10{padding-bottom:10}.p-l-10{padding-left:10}.p-x-10{padding-right:10;padding-left:10}.p-y-10{padding-top:10;padding-bottom:10}.p-12{padding:12}.p-t-12{padding-top:12}.p-r-12{padding-right:12}.p-b-12{padding-bottom:12}.p-l-12{padding-left:12}.p-x-12{padding-right:12;padding-left:12}.p-y-12{padding-top:12;padding-bottom:12}.p-15{padding:15}.p-t-15{padding-top:15}.p-r-15{padding-right:15}.p-b-15{padding-bottom:15}.p-l-15{padding-left:15}.p-x-15{padding-right:15;padding-left:15}.p-y-15{padding-top:15;padding-bottom:15}.p-16{padding:16}.p-t-16{padding-top:16}.p-r-16{padding-right:16}.p-b-16{padding-bottom:16}.p-l-16{padding-left:16}.p-x-16{padding-right:16;padding-left:16}.p-y-16{padding-top:16;padding-bottom:16}.p-20{padding:20}.p-t-20{padding-top:20}.p-r-20{padding-right:20}.p-b-20{padding-bottom:20}.p-l-20{padding-left:20}.p-x-20{padding-right:20;padding-left:20}.p-y-20{padding-top:20;padding-bottom:20}.p-24{padding:24}.p-t-24{padding-top:24}.p-r-24{padding-right:24}.p-b-24{padding-bottom:24}.p-l-24{padding-left:24}.p-x-24{padding-right:24;padding-left:24}.p-y-24{padding-top:24;padding-bottom:24}.p-25{padding:25}.p-t-25{padding-top:25}.p-r-25{padding-right:25}.p-b-25{padding-bottom:25}.p-l-25{padding-left:25}.p-x-25{padding-right:25;padding-left:25}.p-y-25{padding-top:25;padding-bottom:25}.p-28{padding:28}.p-t-28{padding-top:28}.p-r-28{padding-right:28}.p-b-28{padding-bottom:28}.p-l-28{padding-left:28}.p-x-28{padding-right:28;padding-left:28}.p-y-28{padding-top:28;padding-bottom:28}.p-30{padding:30}.p-t-30{padding-top:30}.p-r-30{padding-right:30}.p-b-30{padding-bottom:30}.p-l-30{padding-left:30}.p-x-30{padding-right:30;padding-left:30}.p-y-30{padding-top:30;padding-bottom:30}.hr-light{height:1;background-color:#e0e0e0;width:100%}.hr-dark{height:1;background-color:#303030;width:100%}.text-left{text-align:left}.text-right{text-align:right}.text-center{text-align:center}.text-lowercase{text-transform:lowercase}.text-uppercase{text-transform:uppercase}.text-capitalize{text-transform:capitalize}.font-weight-normal{font-weight:normal}.font-weight-bold{font-weight:bold}.font-italic{font-style:italic}.t-10{font-size:10}.t-12{font-size:12}.t-14{font-size:14}.t-15{font-size:15}.t-16{font-size:16}.t-17{font-size:17}.t-18{font-size:18}.t-19{font-size:19}.t-20{font-size:20}.t-25{font-size:25}.t-30{font-size:30}.img-rounded{border-radius:5}.img-circle{border-radius:20}.img-thumbnail{border-radius:0}.invisible{visibility:collapse}.pull-left{horizontal-align:left}.pull-right{horizontal-align:right}.m-x-auto{horizontal-align:center}.m-y-auto{vertical-align:center}.text-primary{color:#30bcff}.text-danger{color:#d50000}.text-muted{color:#9e9e9e}.bg-primary{background-color:#30bcff;color:#fff}.bg-danger{background-color:#d50000;color:#fff}.action-bar{background-color:#F8F8F8;color:#212121}.action-bar .action-bar-title{font-weight:bold;font-size:17;vertical-align:center}.action-bar .action-item{font-weight:normal}.activity-indicator{color:#30bcff;width:30;height:30}.btn{color:#30bcff;background-color:transparent;min-height:36;min-width:64;padding:10 10 10 10;font-size:18;margin:8 16 8 16}.btn.btn-active:highlighted{color:#fff;background-color:#c0ebff}.btn-primary{background-color:#30bcff;border-color:#30bcff;color:#fff}.btn-primary.btn-active:highlighted{background-color:#01a0ec;border-color:#01a0ec}.btn-primary.btn-aqua{background-color:#00caab}.btn-primary.btn-blue{background-color:#3d5afe}.btn-primary.btn-brown{background-color:#795548}.btn-primary.btn-forest{background-color:#006968}.btn-primary.btn-grey{background-color:#5c687c}.btn-primary.btn-lemon{background-color:#ffea00;color:#000}.btn-primary.btn-lime{background-color:#aee406;color:#000}.btn-primary.btn-orange{background-color:#f57c00}.btn-primary.btn-purple{background-color:#8130ff}.btn-primary.btn-ruby{background-color:#ff1744}.btn-primary.btn-sky{background-color:#30bcff}.btn-outline{background-color:transparent;border-color:#30bcff;color:#30bcff}.btn-outline.btn-active:highlighted{background-color:#c0ebff}.btn[isEnabled=false]{color:#a4a4a4;background-color:#e0e0e0;border-color:#e0e0e0}.fa{font-family:FontAwesome, fontawesome-webfont}.form .input{padding:16 8 16 8;background-color:transparent}.form .input.input-border{border-width:1;border-color:#e0e0e0;border-radius:2;padding:16}.form .input.input-rounded{border-width:1;border-color:#e0e0e0;border-radius:28;padding:16}.form .input[isEnabled='false']{background-color:#fafafa}.form .input-field{margin:8}.form .input-field .label{font-size:12;color:#bababa}.form .input-field .input{padding:0;margin:0 0 8 0}.form .input-field .hr-light.active,.form .input-field .hr-dark.active{background-color:#30bcff}.form .input-field.input-sides .label{font-size:18;margin:0 0 8 0}.h1,.h2,.h3,.h4,.h5,.h6{margin-bottom:4;font-weight:normal;color:#212121}.body,.body2,.footnote{font-weight:normal;color:#757575}.h1{font-size:32}.h2{font-size:22}.h3{font-size:15}.h4{font-size:12}.h5{font-size:11}.h6{font-size:10}.body{font-size:14}.body2{font-size:17}.footnote{font-size:13}.list-group .list-group-item{color:#212121;font-size:16;margin:0;padding:16}.list-group .list-group-item Label{vertical-align:center}.list-group .list-group-item .thumb{stretch:fill;width:40;height:40;margin-right:16}.list-group .list-group-item.active{background-color:#e0e0e0}.list-group .list-group-item .list-group-item-text{color:#757575;font-size:14}.page{background-color:#fff}.progress{color:#30bcff;background-color:#bababa}.segmented-bar{font-size:13;background-color:#fff;color:#212121;selected-background-color:#30bcff}.sidedrawer-left,.sidedrawer-center{background-color:#fafafa}.sidedrawer-header{background-color:#fafafa;height:148;width:100%}.sidedrawer-left .sidedrawer-header{padding:16 16 0 16}.sidedrawer-center .sidedrawer-header{padding:20 15 0 15}.sidedrawer-header-image{background-color:#e0e0e0}.sidedrawer-left .sidedrawer-header-image{height:64;width:64;border-radius:32;horizontal-align:left;margin-bottom:36}.sidedrawer-center .sidedrawer-header-image{height:74;width:74;border-radius:37;horizontal-align:center;margin-bottom:24}.sidedrawer-header-brand{color:#737373}.sidedrawer-left .sidedrawer-header-brand{horizontal-align:left;font-size:14}.sidedrawer-center .sidedrawer-header-brand{horizontal-align:center;font-size:15}.sidedrawer-list-item{height:48;horizontal-align:left;width:100%;orientation:horizontal}.sidedrawer-list-item .sidedrawer-list-item-icon{width:24;text-align:center;font-size:20;height:48;vertical-align:center}.sidedrawer-list-item.active{color:#fff;background-color:#30bcff}.sidedrawer-list-item.active .sidedrawer-list-item-icon{color:#fff}.sidedrawer-left .sidedrawer-list-item-icon{margin:0 16 0 16}.sidedrawer-center .sidedrawer-list-item-icon{margin:0 0 0 15}.sidedrawer-list-item-text{horizontal-align:left;text-align:left;font-size:15;background-color:transparent;border-width:0.1;width:80%;vertical-align:center}.sidedrawer-left .sidedrawer-list-item-text{padding-left:16}.sidedrawer-center .sidedrawer-list-item-text{padding-left:15}.slider{background-color:#30bcff}.slider[isEnabled=false]{background-color:#e0e0e0;color:#e0e0e0}.switch[checked=true]{background-color:#30bcff}.switch[checked=true][isEnabled=false]{background-color:#e0e0e0;color:#fff}.switch[isEnabled=false]{background-color:#e0e0e0;color:#e0e0e0}.tab-view{selected-color:#30bcff;tabs-background-color:#fff}.tab-view .tab-view-item{background-color:#fff;tabs-background-color:#fff}#login-background{margin-top:-20;background-size:cover;background-position:center}.login-wrap{padding:0 40}.logo-wrap{margin:60 0 10 0;padding:20 0}.logo-wrap .login-logo{text-align:center;font-size:30;font-weight:bold;margin-bottom:10;opacity:1;color:#212121;opacity:.9}.logo-wrap .login-logo-sub{color:#212121;opacity:.8;text-align:center}.login-wrapper{padding:20;background-color:#fff;border-radius:3}.login-wrapper TextField{padding:10 10;margin:10 0 0 0}.go-back{font-size:14;text-align:center;color:#212121;margin-top:10}.btn{border-width:0;font-family:'SF UI Text Medium';font-size:15}.btn-outline{border-width:1}.btn-rounded-sm{border-radius:4}.btn-rounded-lg{border-radius:19}.form{font-family:'SF UI Text Regular'}.form .input{font-size:15}.form .input.input-rounded{border-radius:27}.h1{font-size:32}.slider{margin:10 15}.sidedrawer-list-item-icon,.sidedrawer-list-item{color:#949494}.switch{margin:8 15}.list-group .list-group-item{padding:16 15 16 15}.list-group .list-group-item .thumb{margin-right:15}.list-group .list-group-item .list-group-item-heading{margin-bottom:5}.segmented-bar{margin:0 15;color:#30bcff}\n", ""]);

// exports


/***/ }),

/***/ "../node_modules/css-loader/lib/css-base.js":
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return "@media " + item[2] + "{" + content + "}";
      } else {
        return content;
      }
    }).join("");
  }; // import a list of modules into the list


  list.i = function (modules, mediaQuery) {
    if (typeof modules === "string") modules = [[null, modules, ""]];
    var alreadyImportedModules = {};

    for (var i = 0; i < this.length; i++) {
      var id = this[i][0];
      if (typeof id === "number") alreadyImportedModules[id] = true;
    }

    for (i = 0; i < modules.length; i++) {
      var item = modules[i]; // skip already imported module
      // this implementation is not 100% perfect for weird media query combinations
      //  when a module is imported multiple times with different media queries.
      //  I hope this will never occur (Hey this way we have smaller bundles)

      if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
        if (mediaQuery && !item[2]) {
          item[2] = mediaQuery;
        } else if (mediaQuery) {
          item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
        }

        list.push(item);
      }
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || '';
  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;
  return '/*# ' + data + ' */';
}

/***/ }),

/***/ "../node_modules/nativescript-dev-webpack/load-application-css-regular.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {const loadCss = __webpack_require__("../node_modules/nativescript-dev-webpack/load-application-css.js");

module.exports = function () {
  loadCss(function () {
    const appCssContext = __webpack_require__("./ sync ^\\.\\/app\\.(css|scss|less|sass)$");

    global.registerWebpackModules(appCssContext);
  });
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("../node_modules/nativescript-dev-webpack/node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../node_modules/nativescript-dev-webpack/load-application-css.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = function (loadModuleFn) {
  const application = __webpack_require__("tns-core-modules/application");

  __webpack_require__("tns-core-modules/ui/styling/style-scope");

  loadModuleFn();
  application.loadAppCss();
};

/***/ }),

/***/ "../node_modules/nativescript-dev-webpack/node_modules/webpack/buildin/global.js":
/***/ (function(module, exports) {

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || new Function("return this")();
} catch (e) {
  // This works if the window reference is available
  if (typeof window === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),

/***/ "../node_modules/nativescript-mapbox/mapbox.common.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var view_1 = __webpack_require__("tns-core-modules/ui/core/view");

var content_view_1 = __webpack_require__("tns-core-modules/ui/content-view");

var MapStyle;

(function (MapStyle) {
  MapStyle[MapStyle["DARK"] = "dark"] = "DARK";
  MapStyle[MapStyle["OUTDOORS"] = "outdoors"] = "OUTDOORS";
  MapStyle[MapStyle["LIGHT"] = "light"] = "LIGHT";
  MapStyle[MapStyle["SATELLITE"] = "satellite"] = "SATELLITE";
  MapStyle[MapStyle["SATELLITE_STREETS"] = "satellite_streets"] = "SATELLITE_STREETS";
  MapStyle[MapStyle["STREETS"] = "streets"] = "STREETS";
  MapStyle[MapStyle["TRAFFIC_DAY"] = "traffic_day"] = "TRAFFIC_DAY";
  MapStyle[MapStyle["TRAFFIC_NIGHT"] = "traffic_night"] = "TRAFFIC_NIGHT";
})(MapStyle = exports.MapStyle || (exports.MapStyle = {}));

var MapboxCommon = function () {
  function MapboxCommon() {}

  MapboxCommon.merge = function (obj1, obj2) {
    var result = {};

    for (var i in obj1) {
      if (i in obj2 && typeof obj1[i] === "object" && i !== null) {
        result[i] = this.merge(obj1[i], obj2[i]);
      } else {
        result[i] = obj1[i];
      }
    }

    for (var i in obj2) {
      if (i in result) {
        continue;
      }

      result[i] = obj2[i];
    }

    return result;
  };

  MapboxCommon.prototype.requestFineLocationPermission = function () {
    return new Promise(function (resolve) {
      resolve();
    });
  };

  MapboxCommon.prototype.hasFineLocationPermission = function () {
    return new Promise(function (resolve) {
      resolve(true);
    });
  };

  MapboxCommon.defaults = {
    style: MapStyle.STREETS.toString(),
    mapStyle: MapStyle.STREETS.toString(),
    margins: {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    },
    zoomLevel: 0,
    showUserLocation: false,
    hideLogo: false,
    hideAttribution: true,
    hideCompass: false,
    disableRotation: false,
    disableScroll: false,
    disableZoom: false,
    disableTilt: false,
    delay: 0
  };
  return MapboxCommon;
}();

exports.MapboxCommon = MapboxCommon;

var MapboxViewCommonBase = function (_super) {
  __extends(MapboxViewCommonBase, _super);

  function MapboxViewCommonBase() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  MapboxViewCommonBase.prototype.addMarkers = function (markers) {
    return this.mapbox.addMarkers(markers, this.getNativeMapView());
  };

  MapboxViewCommonBase.prototype.removeMarkers = function (options) {
    return this.mapbox.removeMarkers(options, this.getNativeMapView());
  };

  MapboxViewCommonBase.prototype.setOnMapClickListener = function (listener) {
    return this.mapbox.setOnMapClickListener(listener, this.getNativeMapView());
  };

  MapboxViewCommonBase.prototype.setOnMapLongClickListener = function (listener) {
    return this.mapbox.setOnMapLongClickListener(listener, this.getNativeMapView());
  };

  MapboxViewCommonBase.prototype.setOnScrollListener = function (listener, nativeMap) {
    return this.mapbox.setOnScrollListener(listener, this.getNativeMapView());
  };

  MapboxViewCommonBase.prototype.setOnFlingListener = function (listener, nativeMap) {
    return this.mapbox.setOnFlingListener(listener, this.getNativeMapView());
  };

  MapboxViewCommonBase.prototype.setOnCameraMoveListener = function (listener, nativeMap) {
    return this.mapbox.setOnCameraMoveListener(listener, this.getNativeMapView());
  };

  MapboxViewCommonBase.prototype.setOnCameraMoveCancelListener = function (listener, nativeMap) {
    return this.mapbox.setOnCameraMoveCancelListener(listener, this.getNativeMapView());
  };

  MapboxViewCommonBase.prototype.setOnCameraIdleListener = function (listener, nativeMap) {
    return this.mapbox.setOnCameraIdleListener(listener, this.getNativeMapView());
  };

  MapboxViewCommonBase.prototype.getViewport = function () {
    return this.mapbox.getViewport(this.getNativeMapView());
  };

  MapboxViewCommonBase.prototype.setViewport = function (options) {
    return this.mapbox.setViewport(options, this.getNativeMapView());
  };

  MapboxViewCommonBase.prototype.setMapStyle = function (style) {
    return this.mapbox.setMapStyle(style, this.getNativeMapView());
  };

  MapboxViewCommonBase.prototype.getCenter = function () {
    return this.mapbox.getCenter(this.getNativeMapView());
  };

  MapboxViewCommonBase.prototype.setCenter = function (options) {
    return this.mapbox.setCenter(options, this.getNativeMapView());
  };

  MapboxViewCommonBase.prototype.getZoomLevel = function () {
    return this.mapbox.getZoomLevel(this.getNativeMapView());
  };

  MapboxViewCommonBase.prototype.setZoomLevel = function (options) {
    return this.mapbox.setZoomLevel(options, this.getNativeMapView());
  };

  MapboxViewCommonBase.prototype.getTilt = function () {
    return this.mapbox.getTilt(this.getNativeMapView());
  };

  MapboxViewCommonBase.prototype.setTilt = function (options) {
    return this.mapbox.setTilt(options, this.getNativeMapView());
  };

  MapboxViewCommonBase.prototype.getUserLocation = function () {
    return this.mapbox.getUserLocation(this.getNativeMapView());
  };

  MapboxViewCommonBase.prototype.trackUser = function (options) {
    return this.mapbox.trackUser(options, this.getNativeMapView());
  };

  MapboxViewCommonBase.prototype.queryRenderedFeatures = function (options) {
    return this.mapbox.queryRenderedFeatures(options, this.getNativeMapView());
  };

  MapboxViewCommonBase.prototype.addPolygon = function (options) {
    return this.mapbox.addPolygon(options, this.getNativeMapView());
  };

  MapboxViewCommonBase.prototype.removePolygons = function (ids) {
    return this.mapbox.removePolygons(ids, this.getNativeMapView());
  };

  MapboxViewCommonBase.prototype.addPolyline = function (options) {
    return this.mapbox.addPolyline(options, this.getNativeMapView());
  };

  MapboxViewCommonBase.prototype.removePolylines = function (ids) {
    return this.mapbox.removePolylines(ids, this.getNativeMapView());
  };

  MapboxViewCommonBase.prototype.animateCamera = function (options) {
    return this.mapbox.animateCamera(options, this.getNativeMapView());
  };

  MapboxViewCommonBase.prototype.destroy = function () {
    return this.mapbox.destroy(this.getNativeMapView());
  };

  return MapboxViewCommonBase;
}(content_view_1.ContentView);

exports.MapboxViewCommonBase = MapboxViewCommonBase;
exports.zoomLevelProperty = new view_1.Property({
  name: "zoomLevel"
});
exports.zoomLevelProperty.register(MapboxViewCommonBase);
exports.accessTokenProperty = new view_1.Property({
  name: "accessToken"
});
exports.accessTokenProperty.register(MapboxViewCommonBase);
exports.mapStyleProperty = new view_1.Property({
  name: "mapStyle"
});
exports.mapStyleProperty.register(MapboxViewCommonBase);
exports.latitudeProperty = new view_1.Property({
  name: "latitude"
});
exports.latitudeProperty.register(MapboxViewCommonBase);
exports.longitudeProperty = new view_1.Property({
  name: "longitude"
});
exports.longitudeProperty.register(MapboxViewCommonBase);
exports.showUserLocationProperty = new view_1.Property({
  name: "showUserLocation",
  defaultValue: MapboxCommon.defaults.showUserLocation,
  valueConverter: view_1.booleanConverter
});
exports.showUserLocationProperty.register(MapboxViewCommonBase);
exports.hideLogoProperty = new view_1.Property({
  name: "hideLogo",
  defaultValue: MapboxCommon.defaults.hideLogo,
  valueConverter: view_1.booleanConverter
});
exports.hideLogoProperty.register(MapboxViewCommonBase);
exports.hideAttributionProperty = new view_1.Property({
  name: "hideAttribution",
  defaultValue: MapboxCommon.defaults.hideAttribution,
  valueConverter: view_1.booleanConverter
});
exports.hideAttributionProperty.register(MapboxViewCommonBase);
exports.hideCompassProperty = new view_1.Property({
  name: "hideCompass",
  defaultValue: MapboxCommon.defaults.hideCompass,
  valueConverter: view_1.booleanConverter
});
exports.hideCompassProperty.register(MapboxViewCommonBase);
exports.disableZoomProperty = new view_1.Property({
  name: "disableZoom",
  defaultValue: MapboxCommon.defaults.disableZoom,
  valueConverter: view_1.booleanConverter
});
exports.disableZoomProperty.register(MapboxViewCommonBase);
exports.disableRotationProperty = new view_1.Property({
  name: "disableRotation",
  defaultValue: MapboxCommon.defaults.disableRotation,
  valueConverter: view_1.booleanConverter
});
exports.disableRotationProperty.register(MapboxViewCommonBase);
exports.disableScrollProperty = new view_1.Property({
  name: "disableScroll",
  defaultValue: MapboxCommon.defaults.disableScroll,
  valueConverter: view_1.booleanConverter
});
exports.disableScrollProperty.register(MapboxViewCommonBase);
exports.disableTiltProperty = new view_1.Property({
  name: "disableTilt",
  defaultValue: MapboxCommon.defaults.disableTilt,
  valueConverter: view_1.booleanConverter
});
exports.disableTiltProperty.register(MapboxViewCommonBase);
exports.delayProperty = new view_1.Property({
  name: "delay"
});
exports.delayProperty.register(MapboxViewCommonBase);

var MapboxViewBase = function (_super) {
  __extends(MapboxViewBase, _super);

  function MapboxViewBase() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.config = {};
    return _this;
  }

  MapboxViewBase.prototype[exports.zoomLevelProperty.setNative] = function (value) {
    this.config.zoomLevel = +value;
  };

  MapboxViewBase.prototype[exports.mapStyleProperty.setNative] = function (value) {
    this.config.style = value;
    this.config.mapStyle = value;
  };

  MapboxViewBase.prototype[exports.accessTokenProperty.setNative] = function (value) {
    this.config.accessToken = value;
  };

  MapboxViewBase.prototype[exports.delayProperty.setNative] = function (value) {
    this.config.delay = parseInt("" + value);
  };

  MapboxViewBase.prototype[exports.latitudeProperty.setNative] = function (value) {
    this.config.center = this.config.center || {};
    this.config.center.lat = +value;
  };

  MapboxViewBase.prototype[exports.longitudeProperty.setNative] = function (value) {
    this.config.center = this.config.center || {};
    this.config.center.lng = +value;
  };

  MapboxViewBase.prototype[exports.showUserLocationProperty.setNative] = function (value) {
    this.config.showUserLocation = value;
  };

  MapboxViewBase.prototype[exports.hideLogoProperty.setNative] = function (value) {
    this.config.hideLogo = value;
  };

  MapboxViewBase.prototype[exports.hideAttributionProperty.setNative] = function (value) {
    this.config.hideAttribution = value;
  };

  MapboxViewBase.prototype[exports.hideCompassProperty.setNative] = function (value) {
    this.config.hideCompass = value;
  };

  MapboxViewBase.prototype[exports.disableZoomProperty.setNative] = function (value) {
    this.config.disableZoom = value;
  };

  MapboxViewBase.prototype[exports.disableRotationProperty.setNative] = function (value) {
    this.config.disableRotation = value;
  };

  MapboxViewBase.prototype[exports.disableScrollProperty.setNative] = function (value) {
    this.config.disableScroll = value;
  };

  MapboxViewBase.prototype[exports.disableTiltProperty.setNative] = function (value) {
    this.config.disableTilt = value;
  };

  MapboxViewBase.mapReadyEvent = "mapReady";
  MapboxViewBase.locationPermissionGrantedEvent = "locationPermissionGranted";
  MapboxViewBase.locationPermissionDeniedEvent = "locationPermissionDenied";
  return MapboxViewBase;
}(MapboxViewCommonBase);

exports.MapboxViewBase = MapboxViewBase;

/***/ }),

/***/ "../node_modules/nativescript-mapbox/mapbox.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var fs = __webpack_require__("tns-core-modules/file-system");

var imgSrc = __webpack_require__("tns-core-modules/image-source");

var utils = __webpack_require__("tns-core-modules/utils/utils");

var http = __webpack_require__("tns-core-modules/http");

var mapbox_common_1 = __webpack_require__("../node_modules/nativescript-mapbox/mapbox.common.js");

exports.MapStyle = mapbox_common_1.MapStyle;

var color_1 = __webpack_require__("tns-core-modules/color");

var _markers = [];
var _markerIconDownloadCache = [];

var _mapView;

var _mapbox = {};

var _delegate;

var _setMapboxMapOptions = function _setMapboxMapOptions(mapView, settings) {
  mapView.logoView.hidden = settings.hideLogo;
  mapView.attributionButton.hidden = settings.hideAttribution;
  mapView.compassView.hidden = settings.hideCompass;
  mapView.rotateEnabled = !settings.disableRotation;
  mapView.scrollEnabled = !settings.disableScroll;
  mapView.zoomEnabled = !settings.disableZoom;
  mapView.allowsTilting = !settings.disableTilt;

  if (settings.center && settings.center.lat && settings.center.lng) {
    var centerCoordinate = CLLocationCoordinate2DMake(settings.center.lat, settings.center.lng);
    mapView.setCenterCoordinateZoomLevelAnimated(centerCoordinate, settings.zoomLevel, false);
  } else {
    mapView.setZoomLevelAnimated(settings.zoomLevel, false);
  }

  mapView.showsUserLocation = settings.showUserLocation;
  mapView.autoresizingMask = 2 | 16;
};

var _getMapStyle = function _getMapStyle(input) {
  if (/^mapbox:\/\/styles/.test(input) || /^http:\/\//.test(input) || /^https:\/\//.test(input)) {
    return NSURL.URLWithString(input);
  } else if (/^~\//.test(input)) {
    var assetPath = 'file://' + fs.knownFolders.currentApp().path + '/';
    input = input.replace(/^~\//, assetPath);
    return NSURL.URLWithString(input);
  } else if (input === mapbox_common_1.MapStyle.LIGHT || input === mapbox_common_1.MapStyle.LIGHT.toString()) {
    return MGLStyle.lightStyleURL;
  } else if (input === mapbox_common_1.MapStyle.DARK || input === mapbox_common_1.MapStyle.DARK.toString()) {
    return MGLStyle.darkStyleURL;
  } else if (input === mapbox_common_1.MapStyle.OUTDOORS || input === mapbox_common_1.MapStyle.OUTDOORS.toString()) {
    return MGLStyle.outdoorsStyleURL;
  } else if (input === mapbox_common_1.MapStyle.SATELLITE || input === mapbox_common_1.MapStyle.SATELLITE.toString()) {
    return MGLStyle.satelliteStyleURL;
  } else if (input === mapbox_common_1.MapStyle.SATELLITE_STREETS || input === mapbox_common_1.MapStyle.SATELLITE_STREETS.toString()) {
    return MGLStyle.satelliteStreetsStyleURL;
  } else if (input === mapbox_common_1.MapStyle.TRAFFIC_DAY || input === mapbox_common_1.MapStyle.TRAFFIC_DAY.toString()) {
    return NSURL.URLWithString("mapbox://styles/mapbox/traffic-day-v2");
  } else if (input === mapbox_common_1.MapStyle.TRAFFIC_NIGHT || input === mapbox_common_1.MapStyle.TRAFFIC_NIGHT.toString()) {
    return NSURL.URLWithString("mapbox://styles/mapbox/traffic-night-v2");
  } else {
    return MGLStyle.streetsStyleURL;
  }
};

var _getTrackingMode = function _getTrackingMode(input) {
  if (input === "FOLLOW") {
    return 1;
  } else if (input === "FOLLOW_WITH_HEADING") {
    return 2;
  } else if (input === "FOLLOW_WITH_COURSE") {
    return 3;
  } else {
    return 0;
  }
};

var MapboxView = function (_super) {
  __extends(MapboxView, _super);

  function MapboxView() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  MapboxView.prototype.getNativeMapView = function () {
    return this.mapView;
  };

  MapboxView.prototype.createNativeView = function () {
    var _this = this;

    var v = _super.prototype.createNativeView.call(this);

    setTimeout(function () {
      _this.initMap();
    }, 0);
    return v;
  };

  MapboxView.prototype.initMap = function () {
    var _this = this;

    if (!this.mapView && this.config.accessToken) {
      this.mapbox = new Mapbox();
      var settings_1 = Mapbox.merge(this.config, Mapbox.defaults);

      var drawMap = function drawMap() {
        MGLAccountManager.accessToken = settings_1.accessToken;
        _this.mapView = MGLMapView.alloc().initWithFrameStyleURL(CGRectMake(0, 0, _this.nativeView.frame.size.width, _this.nativeView.frame.size.height), _getMapStyle(settings_1.style));
        _this.mapView.delegate = _this.delegate = MGLMapViewDelegateImpl.new().initWithCallback(function () {
          _this.notify({
            eventName: mapbox_common_1.MapboxViewBase.mapReadyEvent,
            object: _this,
            map: _this,
            ios: _this.mapView
          });

          _this.notify({
            eventName: mapbox_common_1.MapboxViewBase.locationPermissionGrantedEvent,
            object: _this,
            map: _this,
            ios: _this.mapView
          });
        });

        _setMapboxMapOptions(_this.mapView, settings_1);

        _markers = [];

        _this.nativeView.addSubview(_this.mapView);
      };

      setTimeout(drawMap, settings_1.delay ? settings_1.delay : 0);
    }
  };

  MapboxView.prototype.onLayout = function (left, top, right, bottom) {
    _super.prototype.onLayout.call(this, left, top, right, bottom);

    if (this.mapView) {
      this.mapView.layer.frame = this.ios.layer.bounds;
    }
  };

  return MapboxView;
}(mapbox_common_1.MapboxViewBase);

exports.MapboxView = MapboxView;

var Mapbox = function (_super) {
  __extends(Mapbox, _super);

  function Mapbox() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  Mapbox.prototype.show = function (options) {
    return new Promise(function (resolve, reject) {
      try {
        var settings = Mapbox.merge(options, Mapbox.defaults);

        if (settings.accessToken === undefined) {
          reject("Please set the 'accessToken' parameter");
          return;
        }

        if (_mapView) {
          _mapView.removeFromSuperview();
        }

        var view_1 = utils.ios.getter(UIApplication, UIApplication.sharedApplication).keyWindow.rootViewController.view,
            frameRect = view_1.frame,
            mapFrame = CGRectMake(settings.margins.left, settings.margins.top, frameRect.size.width - settings.margins.left - settings.margins.right, frameRect.size.height - settings.margins.top - settings.margins.bottom),
            styleURL = _getMapStyle(settings.style);

        MGLAccountManager.accessToken = settings.accessToken;
        _mapbox.mapView = MGLMapView.alloc().initWithFrameStyleURL(mapFrame, styleURL);

        _setMapboxMapOptions(_mapbox.mapView, settings);

        _mapbox.mapView.delegate = _delegate = MGLMapViewDelegateImpl.new().initWithCallback(function (mapView) {
          resolve({
            ios: mapView
          });
        });
        _markers = [];

        _addMarkers(settings.markers);

        setTimeout(function () {
          view_1.addSubview(_mapbox.mapView);
        }, 500);
      } catch (ex) {
        console.log("Error in mapbox.show: " + ex);
        reject(ex);
      }
    });
  };

  Mapbox.prototype.hide = function () {
    return new Promise(function (resolve, reject) {
      try {
        if (_mapbox.mapView) {
          _mapbox.mapView.removeFromSuperview();
        }

        resolve();
      } catch (ex) {
        console.log("Error in mapbox.hide: " + ex);
        reject(ex);
      }
    });
  };

  Mapbox.prototype.unhide = function () {
    return new Promise(function (resolve, reject) {
      try {
        if (_mapbox.mapView) {
          var view = utils.ios.getter(UIApplication, UIApplication.sharedApplication).keyWindow.rootViewController.view;
          view.addSubview(_mapbox.mapView);
          resolve();
        } else {
          reject("No map found");
        }
      } catch (ex) {
        console.log("Error in mapbox.unhide: " + ex);
        reject(ex);
      }
    });
  };

  Mapbox.prototype.destroy = function (nativeMap) {
    return new Promise(function (resolve, reject) {
      var theMap = nativeMap || _mapbox.mapView;

      if (theMap) {
        theMap.removeFromSuperview();
        theMap.delegate = null;
        _mapbox = {};
      }

      resolve();
    });
  };

  Mapbox.prototype.setMapStyle = function (style, nativeMap) {
    return new Promise(function (resolve, reject) {
      try {
        var theMap = nativeMap || _mapbox.mapView;
        theMap.styleURL = _getMapStyle(style);
        resolve();
      } catch (ex) {
        console.log("Error in mapbox.setMapStyle: " + ex);
        reject(ex);
      }
    });
  };

  Mapbox.prototype.addMarkers = function (markers, nativeMap) {
    return new Promise(function (resolve, reject) {
      try {
        var theMap = nativeMap || _mapbox.mapView;

        _addMarkers(markers, theMap);

        resolve();
      } catch (ex) {
        console.log("Error in mapbox.addMarkers: " + ex);
        reject(ex);
      }
    });
  };

  Mapbox.prototype.removeMarkers = function (ids, nativeMap) {
    return new Promise(function (resolve, reject) {
      try {
        var theMap = nativeMap || _mapbox.mapView;
        var markersToRemove_1 = [];

        _markers.forEach(function (marker) {
          if (!ids || marker.id && ids.indexOf(marker.id) > -1) {
            markersToRemove_1.push(marker.ios);
          }
        });

        if (ids) {
          _markers = _markers.filter(function (marker) {
            return ids.indexOf(marker.id) < 0;
          });
        } else {
          _markers = [];
        }

        if (markersToRemove_1.length > 0) {
          theMap.removeAnnotations(markersToRemove_1);
        }

        resolve();
      } catch (ex) {
        console.log("Error in mapbox.removeMarkers: " + ex);
        reject(ex);
      }
    });
  };

  Mapbox.prototype.setCenter = function (options, nativeMap) {
    return new Promise(function (resolve, reject) {
      try {
        var theMap = nativeMap || _mapbox.mapView;
        var animated = options.animated === undefined || options.animated;
        var coordinate = CLLocationCoordinate2DMake(options.lat, options.lng);
        theMap.setCenterCoordinateAnimated(coordinate, animated);
        resolve();
      } catch (ex) {
        console.log("Error in mapbox.setCenter: " + ex);
        reject(ex);
      }
    });
  };

  Mapbox.prototype.getCenter = function (nativeMap) {
    return new Promise(function (resolve, reject) {
      try {
        var theMap = nativeMap || _mapbox.mapView;
        var coordinate = theMap.centerCoordinate;
        resolve({
          lat: coordinate.latitude,
          lng: coordinate.longitude
        });
      } catch (ex) {
        console.log("Error in mapbox.getCenter: " + ex);
        reject(ex);
      }
    });
  };

  Mapbox.prototype.setZoomLevel = function (options, nativeMap) {
    return new Promise(function (resolve, reject) {
      try {
        var theMap = nativeMap || _mapbox.mapView;
        var animated = options.animated === undefined || options.animated;
        var level = options.level;

        if (level >= 0 && level <= 20) {
          theMap.setZoomLevelAnimated(level, animated);
          resolve();
        } else {
          reject("invalid zoomlevel, use any double value from 0 to 20 (like 8.3)");
        }
      } catch (ex) {
        console.log("Error in mapbox.setZoomLevel: " + ex);
        reject(ex);
      }
    });
  };

  Mapbox.prototype.getZoomLevel = function (nativeMap) {
    return new Promise(function (resolve, reject) {
      try {
        var theMap = nativeMap || _mapbox.mapView;
        resolve(theMap.zoomLevel);
      } catch (ex) {
        console.log("Error in mapbox.getZoomLevel: " + ex);
        reject(ex);
      }
    });
  };

  Mapbox.prototype.setTilt = function (options, nativeMap) {
    return new Promise(function (resolve, reject) {
      try {
        var theMap = nativeMap || _mapbox.mapView;
        var cam = theMap.camera;
        cam.pitch = options.tilt;
        var durationMs = options.duration ? options.duration : 5000;
        theMap.setCameraWithDurationAnimationTimingFunction(cam, durationMs / 1000, CAMediaTimingFunction.functionWithName(kCAMediaTimingFunctionEaseInEaseOut));
        setTimeout(function () {
          resolve();
        }, durationMs);
      } catch (ex) {
        console.log("Error in mapbox.setTilt: " + ex);
        reject(ex);
      }
    });
  };

  Mapbox.prototype.getTilt = function (nativeMap) {
    return new Promise(function (resolve, reject) {
      try {
        var theMap = nativeMap || _mapbox.mapView;
        resolve(theMap.camera.pitch);
      } catch (ex) {
        console.log("Error in mapbox.getTilt: " + ex);
        reject(ex);
      }
    });
  };

  Mapbox.prototype.getUserLocation = function (nativeMap) {
    return new Promise(function (resolve, reject) {
      try {
        var theMap = nativeMap || _mapbox.mapView;
        var loc = theMap.userLocation;

        if (loc === null) {
          reject("Location not available");
        } else {
          resolve({
            location: {
              lat: loc.coordinate.latitude,
              lng: loc.coordinate.longitude
            },
            speed: loc.location ? loc.location.speed : 0
          });
        }
      } catch (ex) {
        console.log("Error in mapbox.getUserLocation: " + ex);
        reject(ex);
      }
    });
  };

  Mapbox.prototype.queryRenderedFeatures = function (options, nativeMap) {
    return new Promise(function (resolve, reject) {
      try {
        var theMap = nativeMap || _mapbox.mapView;
        var point = options.point;

        if (point === undefined) {
          reject("Please set the 'point' parameter");
          return;
        }

        var _a = theMap.convertCoordinateToPointToView({
          latitude: point.lat,
          longitude: point.lng
        }, theMap),
            x = _a.x,
            y = _a.y;

        var features = theMap.visibleFeaturesAtPoint({
          x: x,
          y: y
        });
        var result = [];

        for (var i = 0; i < features.count; i++) {
          var feature = features.objectAtIndex(i);
          result.push({
            id: feature.identifier,
            properties: JSON.parse(feature.attributes.toString())
          });
        }

        resolve(result);
      } catch (ex) {
        console.log("Error in mapbox.queryRenderedFeatures: " + ex);
        reject(ex);
      }
    });
  };

  Mapbox.prototype.addPolygon = function (options, nativeMap) {
    return new Promise(function (resolve, reject) {
      var theMap = nativeMap || _mapbox.mapView;
      var points = options.points;

      if (points === undefined) {
        reject("Please set the 'points' parameter");
        return;
      }

      var coordinateArray = [];
      points.forEach(function (point) {
        return coordinateArray.push([point.lng, point.lat]);
      });
      var polygonID = "polygon_" + (options.id || new Date().getTime());

      if (theMap.style.sourceWithIdentifier(polygonID)) {
        reject("Remove the polygon with this id first with 'removePolygons': " + polygonID);
        return;
      }

      var geoJSON = "{\"type\": \"FeatureCollection\", \"features\": [{\"type\": \"Feature\",\"properties\": {},\"geometry\": {\"type\": \"Polygon\", \"coordinates\": [" + JSON.stringify(coordinateArray) + "]}}]}";
      var geoDataStr = NSString.stringWithString(geoJSON);
      var geoData = geoDataStr.dataUsingEncoding(NSUTF8StringEncoding);
      var geoDataBase64Enc = geoData.base64EncodedStringWithOptions(0);
      var geo = NSData.alloc().initWithBase64EncodedStringOptions(geoDataBase64Enc, null);
      var shape = MGLShape.shapeWithDataEncodingError(geo, NSUTF8StringEncoding);
      var source = MGLShapeSource.alloc().initWithIdentifierShapeOptions(polygonID, shape, null);
      theMap.style.addSource(source);

      if (options.strokeColor || options.strokeWidth || options.strokeOpacity) {
        var strokeLayer = MGLLineStyleLayer.alloc().initWithIdentifierSource(polygonID + "_stroke", source);
        strokeLayer.lineColor = NSExpression.expressionForConstantValue(!options.strokeColor ? UIColor.blackColor : options.strokeColor instanceof color_1.Color ? options.strokeColor.ios : new color_1.Color(options.strokeColor).ios);
        strokeLayer.lineWidth = NSExpression.expressionForConstantValue(options.strokeWidth || 5);
        strokeLayer.lineOpacity = NSExpression.expressionForConstantValue(options.strokeOpacity === undefined ? 1 : options.strokeOpacity);
        theMap.style.addLayer(strokeLayer);
      }

      var layer = MGLFillStyleLayer.alloc().initWithIdentifierSource(polygonID, source);
      layer.fillColor = NSExpression.expressionForConstantValue(!options.fillColor ? UIColor.blackColor : options.fillColor instanceof color_1.Color ? options.fillColor.ios : new color_1.Color(options.fillColor).ios);
      layer.fillOpacity = NSExpression.expressionForConstantValue(options.fillOpacity === undefined ? 1 : options.fillOpacity);
      theMap.style.addLayer(layer);
      resolve();
    });
  };

  Mapbox.prototype.addPolyline = function (options, nativeMap) {
    return new Promise(function (resolve, reject) {
      var theMap = nativeMap || _mapbox.mapView;
      var points = options.points;

      if (points === undefined) {
        reject("Please set the 'points' parameter");
        return;
      }

      var coordinateArray = [];
      points.forEach(function (point) {
        return coordinateArray.push([point.lng, point.lat]);
      });
      var polylineID = "polyline_" + (options.id || new Date().getTime());

      if (theMap.style.sourceWithIdentifier(polylineID)) {
        reject("Remove the polyline with this id first with 'removePolylines': " + polylineID);
        return;
      }

      var geoJSON = "{\"type\": \"FeatureCollection\", \"features\": [{\"type\": \"Feature\",\"properties\": {},\"geometry\": {\"type\": \"LineString\", \"coordinates\": " + JSON.stringify(coordinateArray) + "}}]}";
      var geoDataStr = NSString.stringWithString(geoJSON);
      var geoData = geoDataStr.dataUsingEncoding(NSUTF8StringEncoding);
      var geoDataBase64Enc = geoData.base64EncodedStringWithOptions(0);
      var geo = NSData.alloc().initWithBase64EncodedStringOptions(geoDataBase64Enc, null);
      var shape = MGLShape.shapeWithDataEncodingError(geo, NSUTF8StringEncoding);
      var source = MGLShapeSource.alloc().initWithIdentifierShapeOptions(polylineID, shape, null);
      theMap.style.addSource(source);
      var layer = MGLLineStyleLayer.alloc().initWithIdentifierSource(polylineID, source);
      layer.lineColor = NSExpression.expressionForConstantValue(!options.color ? UIColor.blackColor : options.color instanceof color_1.Color ? options.color.ios : new color_1.Color(options.color).ios);
      layer.lineWidth = NSExpression.expressionForConstantValue(options.width || 5);
      layer.lineOpacity = NSExpression.expressionForConstantValue(options.opacity === undefined ? 1 : options.opacity);
      theMap.style.addLayer(layer);
      resolve();
    });
  };

  Mapbox.prototype.removePolyById = function (theMap, id) {
    var layer = theMap.style.layerWithIdentifier(id);

    if (layer !== null) {
      theMap.style.removeLayer(layer);
    }

    layer = theMap.style.layerWithIdentifier(id + "_stroke");

    if (layer !== null) {
      theMap.style.removeLayer(layer);
    }

    var source = theMap.style.sourceWithIdentifier(id);

    if (source !== null) {
      theMap.style.removeSource(source);
    }
  };

  Mapbox.prototype.removePolygons = function (ids, nativeMap) {
    var _this = this;

    return new Promise(function (resolve, reject) {
      var theMap = nativeMap || _mapbox.mapView;
      ids.map(function (id) {
        return _this.removePolyById(theMap, "polygon_" + id);
      });
      resolve();
    });
  };

  Mapbox.prototype.removePolylines = function (ids, nativeMap) {
    var _this = this;

    return new Promise(function (resolve, reject) {
      var theMap = nativeMap || _mapbox.mapView;
      ids.map(function (id) {
        return _this.removePolyById(theMap, "polyline_" + id);
      });
      resolve();
    });
  };

  Mapbox.prototype.animateCamera = function (options, nativeMap) {
    return new Promise(function (resolve, reject) {
      try {
        var theMap = nativeMap || _mapbox.mapView;
        var target = options.target;

        if (target === undefined) {
          reject("Please set the 'target' parameter");
          return;
        }

        var cam = theMap.camera;
        cam.centerCoordinate = CLLocationCoordinate2DMake(target.lat, target.lng);

        if (options.altitude) {
          cam.altitude = options.altitude;
        }

        if (options.bearing) {
          cam.heading = options.bearing;
        }

        if (options.tilt) {
          cam.pitch = options.tilt;
        }

        var durationMs = options.duration ? options.duration : 10000;
        theMap.setCameraWithDurationAnimationTimingFunction(cam, durationMs / 1000, CAMediaTimingFunction.functionWithName(kCAMediaTimingFunctionEaseInEaseOut));
        setTimeout(function () {
          resolve();
        }, durationMs);
      } catch (ex) {
        console.log("Error in mapbox.animateCamera: " + ex);
        reject(ex);
      }
    });
  };

  Mapbox.prototype.setOnMapClickListener = function (listener, nativeMap) {
    var _this = this;

    return new Promise(function (resolve, reject) {
      try {
        var theMap = nativeMap || _mapbox.mapView;

        if (!theMap) {
          reject("No map has been loaded");
          return;
        }

        theMap['mapTapHandler'] = MapTapHandlerImpl.initWithOwnerAndListenerForMap(new WeakRef(_this), listener, theMap);
        var tapGestureRecognizer = UITapGestureRecognizer.alloc().initWithTargetAction(theMap['mapTapHandler'], "tap");

        for (var i = 0; i < theMap.gestureRecognizers.count; i++) {
          var recognizer = theMap.gestureRecognizers.objectAtIndex(i);

          if (recognizer instanceof UITapGestureRecognizer) {
            tapGestureRecognizer.requireGestureRecognizerToFail(recognizer);
          }
        }

        theMap.addGestureRecognizer(tapGestureRecognizer);
        resolve();
      } catch (ex) {
        console.log("Error in mapbox.setOnMapClickListener: " + ex);
        reject(ex);
      }
    });
  };

  Mapbox.prototype.setOnMapLongClickListener = function (listener, nativeMap) {
    var _this = this;

    return new Promise(function (resolve, reject) {
      try {
        var theMap = nativeMap || _mapbox.mapView;

        if (!theMap) {
          reject("No map has been loaded");
          return;
        }

        theMap['mapLongPressHandler'] = MapLongPressHandlerImpl.initWithOwnerAndListenerForMap(new WeakRef(_this), listener, theMap);
        var longPressGestureRecognizer = UILongPressGestureRecognizer.alloc().initWithTargetAction(theMap['mapLongPressHandler'], "longPress");

        for (var i = 0; i < theMap.gestureRecognizers.count; i++) {
          var recognizer = theMap.gestureRecognizers.objectAtIndex(i);

          if (recognizer instanceof UILongPressGestureRecognizer) {
            longPressGestureRecognizer.requireGestureRecognizerToFail(recognizer);
          }
        }

        theMap.addGestureRecognizer(longPressGestureRecognizer);
        resolve();
      } catch (ex) {
        console.log("Error in mapbox.setOnMapClickListener: " + ex);
        reject(ex);
      }
    });
  };

  Mapbox.prototype.setOnScrollListener = function (listener, nativeMap) {
    var _this = this;

    return new Promise(function (resolve, reject) {
      try {
        var theMap = nativeMap || _mapbox.mapView;

        if (!theMap) {
          reject("No map has been loaded");
          return;
        }

        theMap['mapPanHandler'] = MapPanHandlerImpl.initWithOwnerAndListenerForMap(new WeakRef(_this), listener, theMap);

        for (var i = 0; i < theMap.gestureRecognizers.count; i++) {
          var recognizer = theMap.gestureRecognizers.objectAtIndex(i);

          if (recognizer instanceof UIPanGestureRecognizer) {
            recognizer.addTargetAction(theMap['mapPanHandler'], "pan");
            break;
          }
        }

        resolve();
      } catch (ex) {
        console.log("Error in mapbox.setOnScrollListener: " + ex);
        reject(ex);
      }
    });
  };

  Mapbox.prototype.setOnFlingListener = function (listener, nativeMap) {
    return Promise.reject("'setOnFlingListener' is not supported on iOS");
  };

  Mapbox.prototype.setOnCameraMoveListener = function (listener, nativeMap) {
    return Promise.reject("'setOnCameraMoveListener' not currently supported on iOS");
  };

  Mapbox.prototype.setOnCameraMoveCancelListener = function (listener, nativeMap) {
    return Promise.reject("'setOnCameraMoveCancelListener' not currently supported on iOS");
  };

  Mapbox.prototype.setOnCameraIdleListener = function (listener, nativeMap) {
    return Promise.reject("'setOnCameraIdleListener' not currently supported on iOS");
  };

  Mapbox.prototype.getViewport = function (nativeMap) {
    return new Promise(function (resolve, reject) {
      try {
        var theMap = nativeMap || _mapbox.mapView;

        if (!theMap) {
          reject("No map has been loaded");
          return;
        }

        var visibleBounds = theMap.visibleCoordinateBounds;
        var bounds = {
          north: visibleBounds.ne.latitude,
          east: visibleBounds.ne.longitude,
          south: visibleBounds.sw.latitude,
          west: visibleBounds.sw.longitude
        };
        resolve({
          bounds: bounds,
          zoomLevel: theMap.zoomLevel
        });
      } catch (ex) {
        console.log("Error in mapbox.getViewport: " + ex);
        reject(ex);
      }
    });
  };

  Mapbox.prototype.setViewport = function (options, nativeMap) {
    return new Promise(function (resolve, reject) {
      try {
        var theMap = nativeMap || _mapbox.mapView;

        if (!theMap) {
          reject("No map has been loaded");
          return;
        }

        var bounds = {
          sw: CLLocationCoordinate2DMake(options.bounds.south, options.bounds.west),
          ne: CLLocationCoordinate2DMake(options.bounds.north, options.bounds.east)
        };
        var animated = options.animated === undefined || options.animated;
        var padding = {
          top: 25,
          left: 25,
          bottom: 25,
          right: 25
        };
        theMap.setVisibleCoordinateBoundsEdgePaddingAnimated(bounds, padding, animated);
        resolve();
      } catch (ex) {
        console.log("Error in mapbox.setViewport: " + ex);
        reject(ex);
      }
    });
  };

  Mapbox.prototype.downloadOfflineRegion = function (options) {
    return new Promise(function (resolve, reject) {
      try {
        var styleURL = _getMapStyle(options.style);

        var swCoordinate = CLLocationCoordinate2DMake(options.bounds.south, options.bounds.west);
        var neCoordinate = CLLocationCoordinate2DMake(options.bounds.north, options.bounds.east);
        var bounds = {
          sw: swCoordinate,
          ne: neCoordinate
        };
        var region = MGLTilePyramidOfflineRegion.alloc().initWithStyleURLBoundsFromZoomLevelToZoomLevel(styleURL, bounds, options.minZoom, options.maxZoom);

        if (options.accessToken) {
          MGLAccountManager.accessToken = options.accessToken;
        }

        if (options.onProgress) {
          _addObserver(MGLOfflinePackProgressChangedNotification, function (notification) {
            var offlinePack = notification.object;
            var offlinePackProgress = offlinePack.progress;
            var userInfo = NSKeyedUnarchiver.unarchiveObjectWithData(offlinePack.context);
            var complete = offlinePackProgress.countOfResourcesCompleted === offlinePackProgress.countOfResourcesExpected;
            options.onProgress({
              name: userInfo.objectForKey("name"),
              completed: offlinePackProgress.countOfResourcesCompleted,
              expected: offlinePackProgress.countOfResourcesExpected,
              percentage: Math.round(offlinePackProgress.countOfResourcesCompleted / offlinePackProgress.countOfResourcesExpected * 10000) / 100,
              complete: complete
            });

            if (complete) {
              resolve();
            }
          });
        }

        _addObserver(MGLOfflinePackErrorNotification, function (notification) {
          var offlinePack = notification.object;
          var userInfo = NSKeyedUnarchiver.unarchiveObjectWithData(offlinePack.context);
          var error = notification.userInfo[MGLOfflinePackUserInfoKeyError];
          reject({
            name: userInfo.objectForKey("name"),
            error: "Download error. " + error
          });
        });

        _addObserver(MGLOfflinePackMaximumMapboxTilesReachedNotification, function (notification) {
          var offlinePack = notification.object;
          var userInfo = NSKeyedUnarchiver.unarchiveObjectWithData(offlinePack.context);
          var maximumCount = notification.userInfo[MGLOfflinePackUserInfoKeyMaximumCount];
          console.log("Offline region '" + userInfo.objectForKey("name") + "' reached the tile limit of " + maximumCount);
        });

        var userInfo = {
          "name": options.name
        };
        var context = NSKeyedArchiver.archivedDataWithRootObject(userInfo);
        MGLOfflineStorage.sharedOfflineStorage.addPackForRegionWithContextCompletionHandler(region, context, function (pack, error) {
          if (error) {
            reject(error.localizedFailureReason);
          } else {
            pack.resume();
          }
        });
      } catch (ex) {
        console.log("Error in mapbox.downloadOfflineRegion: " + ex);
        reject(ex);
      }
    });
  };

  Mapbox.prototype.listOfflineRegions = function (options) {
    return new Promise(function (resolve, reject) {
      try {
        var packs = MGLOfflineStorage.sharedOfflineStorage.packs;

        if (!packs) {
          reject("No packs found or Mapbox not ready yet");
          return;
        }

        var regions = [];

        for (var i = 0; i < packs.count; i++) {
          var pack = packs.objectAtIndex(i);
          var region = pack.region;
          var userInfo = NSKeyedUnarchiver.unarchiveObjectWithData(pack.context);
          regions.push({
            name: userInfo.objectForKey("name"),
            style: "" + region.styleURL,
            minZoom: region.minimumZoomLevel,
            maxZoom: region.maximumZoomLevel,
            bounds: {
              north: region.bounds.ne.latitude,
              east: region.bounds.ne.longitude,
              south: region.bounds.sw.latitude,
              west: region.bounds.sw.longitude
            }
          });
        }

        resolve(regions);
      } catch (ex) {
        console.log("Error in mapbox.listOfflineRegions: " + ex);
        reject(ex);
      }
    });
  };

  Mapbox.prototype.deleteOfflineRegion = function (options) {
    return new Promise(function (resolve, reject) {
      try {
        if (!options || !options.name) {
          reject("Pass in the 'name' param");
          return;
        }

        var packs = MGLOfflineStorage.sharedOfflineStorage.packs;
        var found = false;

        for (var i = 0; i < packs.count; i++) {
          var pack = packs.objectAtIndex(i);
          var userInfo = NSKeyedUnarchiver.unarchiveObjectWithData(pack.context);
          var name_1 = userInfo.objectForKey("name");

          if (name_1 === options.name) {
            found = true;
            MGLOfflineStorage.sharedOfflineStorage.removePackWithCompletionHandler(pack, function (error) {
              if (error) {
                reject(error.localizedFailureReason);
              } else {
                resolve();
              }
            });
          }
        }

        if (!found) {
          reject("Region not found");
        }
      } catch (ex) {
        console.log("Error in mapbox.deleteOfflineRegion: " + ex);
        reject(ex);
      }
    });
  };

  Mapbox.prototype.addExtrusion = function (options, nativeMap) {
    return new Promise(function (resolve, reject) {
      try {
        var theMap = nativeMap || _mapbox.mapView;

        if (!theMap) {
          reject("No map has been loaded");
          return;
        }

        resolve();
      } catch (ex) {
        console.log("Error in mapbox.deleteOfflineRegion: " + ex);
        reject(ex);
      }
    });
  };

  Mapbox.prototype.addGeoJsonClustered = function (options, nativeMap) {
    throw new Error('Method not implemented.');
  };

  Mapbox.prototype.trackUser = function (options, nativeMap) {
    return new Promise(function (resolve, reject) {
      try {
        var theMap = nativeMap || _mapbox.mapView;

        if (!theMap) {
          reject("No map has been loaded");
          return;
        }

        if (!theMap.showsUserLocation) {
          reject("The map is not currently showing the user location");
          return;
        }

        theMap.setUserTrackingModeAnimated(_getTrackingMode(options.mode), options.animated !== false);
        resolve();
      } catch (ex) {
        console.log("Error in mapbox.trackUser: " + ex);
        reject(ex);
      }
    });
  };

  return Mapbox;
}(mapbox_common_1.MapboxCommon);

exports.Mapbox = Mapbox;

var _addObserver = function _addObserver(eventName, callback) {
  return utils.ios.getter(NSNotificationCenter, NSNotificationCenter.defaultCenter).addObserverForNameObjectQueueUsingBlock(eventName, null, utils.ios.getter(NSOperationQueue, NSOperationQueue.mainQueue), callback);
};

var _downloadImage = function _downloadImage(marker) {
  return new Promise(function (resolve, reject) {
    console.log(">> _downloadImage");

    if (_markerIconDownloadCache[marker.icon]) {
      marker.iconDownloaded = _markerIconDownloadCache[marker.icon];
      console.log(">> marker.iconDownloaded: " + marker.iconDownloaded);
      resolve(marker);
      return;
    }

    http.getImage(marker.icon).then(function (output) {
      marker.iconDownloaded = output.ios;
      _markerIconDownloadCache[marker.icon] = marker.iconDownloaded;
      resolve(marker);
    }, function (ignoredError) {
      console.log("Download failed for " + marker.icon + " with error: " + ignoredError);
      resolve(marker);
    });
  });
};

var _downloadMarkerImages = function _downloadMarkerImages(markers) {
  var iterations = [];
  var result = [];
  markers.forEach(function (marker) {
    if (marker.icon && marker.icon.startsWith("http")) {
      var p = _downloadImage(marker).then(function (mark) {
        return result.push(mark);
      });

      iterations.push(p);
    } else {
      result.push(marker);
    }
  });
  return Promise.all(iterations).then(function () {
    return result;
  });
};

var _addMarkers = function _addMarkers(markers, nativeMap) {
  if (!markers) {
    console.log("No markers passed");
    return;
  }

  if (!Array.isArray(markers)) {
    console.log("markers must be passed as an Array: [{title: 'foo'}]");
    return;
  }

  var theMap = nativeMap || _mapbox.mapView;

  _downloadMarkerImages(markers).then(function (updatedMarkers) {
    updatedMarkers.forEach(function (marker) {
      var lat = marker.lat;
      var lng = marker.lng;
      var point = MGLPointAnnotation.new();
      point.coordinate = CLLocationCoordinate2DMake(lat, lng);
      point.title = marker.title;
      point.subtitle = marker.subtitle;

      _markers.push(marker);

      theMap.addAnnotation(point);

      if (marker.selected) {
        theMap.selectAnnotationAnimated(point, false);
      }

      marker.ios = point;

      marker.update = function (newSettings) {
        _markers.forEach(function (_marker) {
          if (marker.id === _marker.id) {
            if (newSettings.onTap !== undefined) {
              _marker.onTap = newSettings.onTap;
            }

            if (newSettings.onCalloutTap !== undefined) {
              _marker.onCalloutTap = newSettings.onCalloutTap;
            }

            if (newSettings.title !== undefined) {
              _marker.ios.title = _marker.title = newSettings.title;
            }

            if (newSettings.subtitle !== undefined) {
              _marker.ios.subtitle = _marker.subtitle = newSettings.subtitle;
            }

            if (newSettings.lat && newSettings.lng) {
              _marker.lat = newSettings.lat;
              _marker.lng = newSettings.lng;
              _marker.ios.coordinate = CLLocationCoordinate2DMake(newSettings.lat, newSettings.lng);
            }

            if (newSettings.selected) {
              theMap.selectAnnotationAnimated(_marker.ios, false);
            }
          }
        });
      };
    });
  });
};

var MGLMapViewDelegateImpl = function (_super) {
  __extends(MGLMapViewDelegateImpl, _super);

  function MGLMapViewDelegateImpl() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  MGLMapViewDelegateImpl.new = function () {
    return _super.new.call(this);
  };

  MGLMapViewDelegateImpl.prototype.initWithCallback = function (mapLoadedCallback) {
    this.mapLoadedCallback = mapLoadedCallback;
    return this;
  };

  MGLMapViewDelegateImpl.prototype.mapViewDidFinishLoadingMap = function (mapView) {
    if (this.mapLoadedCallback !== undefined) {
      this.mapLoadedCallback(mapView);
      this.mapLoadedCallback = undefined;
    }
  };

  MGLMapViewDelegateImpl.prototype.mapViewAnnotationCanShowCallout = function (mapView, annotation) {
    return true;
  };

  MGLMapViewDelegateImpl.prototype.mapViewDidFailLoadingMapWithError = function (mapView, error) {};

  MGLMapViewDelegateImpl.prototype.mapViewDidChangeUserTrackingModeAnimated = function (mapView, mode, animated) {};

  MGLMapViewDelegateImpl.prototype.mapViewImageForAnnotation = function (mapView, annotation) {
    var cachedMarker = this.getTappedMarkerDetails(annotation);

    if (cachedMarker) {
      if (cachedMarker.reuseIdentifier) {
        var reusedImage = mapView.dequeueReusableAnnotationImageWithIdentifier(cachedMarker.reuseIdentifier);

        if (reusedImage) {
          return reusedImage;
        }
      }

      if (cachedMarker.icon) {
        if (cachedMarker.icon.startsWith("res://")) {
          var resourcename = cachedMarker.icon.substring("res://".length);
          var imageSource = imgSrc.fromResource(resourcename);

          if (imageSource === null) {
            console.log("Unable to locate " + resourcename);
          } else {
            cachedMarker.reuseIdentifier = cachedMarker.icon;
            return MGLAnnotationImage.annotationImageWithImageReuseIdentifier(imageSource.ios, cachedMarker.reuseIdentifier);
          }
        } else if (cachedMarker.icon.startsWith("http")) {
          if (cachedMarker.iconDownloaded !== null) {
            cachedMarker.reuseIdentifier = cachedMarker.icon;
            return MGLAnnotationImage.annotationImageWithImageReuseIdentifier(cachedMarker.iconDownloaded, cachedMarker.reuseIdentifier);
          }
        } else {
          console.log("Please use res://resourcename, http(s)://imageurl or iconPath to use a local path");
        }
      } else if (cachedMarker.iconPath) {
        var appPath = fs.knownFolders.currentApp().path;
        var iconFullPath = appPath + "/" + cachedMarker.iconPath;

        if (fs.File.exists(iconFullPath)) {
          var image = imgSrc.fromFile(iconFullPath).ios;
          cachedMarker.reuseIdentifier = cachedMarker.iconPath;
          return MGLAnnotationImage.annotationImageWithImageReuseIdentifier(image, cachedMarker.reuseIdentifier);
        }
      }
    }

    return null;
  };

  MGLMapViewDelegateImpl.prototype.mapViewAnnotationCalloutAccessoryControlTapped = function (mapView, annotation, control) {};

  MGLMapViewDelegateImpl.prototype.mapViewDidSelectAnnotation = function (mapView, annotation) {
    var cachedMarker = this.getTappedMarkerDetails(annotation);

    if (cachedMarker && cachedMarker.onTap) {
      cachedMarker.onTap(cachedMarker);
    }
  };

  MGLMapViewDelegateImpl.prototype.mapViewTapOnCalloutForAnnotation = function (mapView, annotation) {
    var cachedMarker = this.getTappedMarkerDetails(annotation);

    if (cachedMarker && cachedMarker.onCalloutTap) {
      cachedMarker.onCalloutTap(cachedMarker);
    }
  };

  MGLMapViewDelegateImpl.prototype.getTappedMarkerDetails = function (tapped) {
    for (var m in _markers) {
      var cached = _markers[m];

      if (cached.lat == tapped.coordinate.latitude && cached.lng == tapped.coordinate.longitude && cached.title == tapped.title && cached.subtitle == tapped.subtitle) {
        return cached;
      }
    }
  };

  MGLMapViewDelegateImpl.ObjCProtocols = [MGLMapViewDelegate];
  return MGLMapViewDelegateImpl;
}(NSObject);

var MapTapHandlerImpl = function (_super) {
  __extends(MapTapHandlerImpl, _super);

  function MapTapHandlerImpl() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  MapTapHandlerImpl.initWithOwnerAndListenerForMap = function (owner, listener, mapView) {
    var handler = MapTapHandlerImpl.new();
    handler._owner = owner;
    handler._listener = listener;
    handler._mapView = mapView;
    return handler;
  };

  MapTapHandlerImpl.prototype.tap = function (recognizer) {
    var tapPoint = recognizer.locationInView(this._mapView);

    var tapCoordinate = this._mapView.convertPointToCoordinateFromView(tapPoint, this._mapView);

    this._listener({
      lat: tapCoordinate.latitude,
      lng: tapCoordinate.longitude
    });
  };

  MapTapHandlerImpl.ObjCExposedMethods = {
    "tap": {
      returns: interop.types.void,
      params: [interop.types.id]
    }
  };
  return MapTapHandlerImpl;
}(NSObject);

var MapLongPressHandlerImpl = function (_super) {
  __extends(MapLongPressHandlerImpl, _super);

  function MapLongPressHandlerImpl() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  MapLongPressHandlerImpl.initWithOwnerAndListenerForMap = function (owner, listener, mapView) {
    var handler = MapLongPressHandlerImpl.new();
    handler._owner = owner;
    handler._listener = listener;
    handler._mapView = mapView;
    return handler;
  };

  MapLongPressHandlerImpl.prototype.longPress = function (recognizer) {
    var longPressPoint = recognizer.locationInView(this._mapView);

    var longPressCoordinate = this._mapView.convertPointToCoordinateFromView(longPressPoint, this._mapView);

    this._listener({
      lat: longPressCoordinate.latitude,
      lng: longPressCoordinate.longitude
    });
  };

  MapLongPressHandlerImpl.ObjCExposedMethods = {
    "longPress": {
      returns: interop.types.void,
      params: [interop.types.id]
    }
  };
  return MapLongPressHandlerImpl;
}(NSObject);

var MapPanHandlerImpl = function (_super) {
  __extends(MapPanHandlerImpl, _super);

  function MapPanHandlerImpl() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  MapPanHandlerImpl.initWithOwnerAndListenerForMap = function (owner, listener, mapView) {
    var handler = MapPanHandlerImpl.new();
    handler._owner = owner;
    handler._listener = listener;
    handler._mapView = mapView;
    return handler;
  };

  MapPanHandlerImpl.prototype.pan = function (recognizer) {
    var panPoint = recognizer.locationInView(this._mapView);

    var panCoordinate = this._mapView.convertPointToCoordinateFromView(panPoint, this._mapView);

    this._listener({
      lat: panCoordinate.latitude,
      lng: panCoordinate.longitude
    });
  };

  MapPanHandlerImpl.ObjCExposedMethods = {
    "pan": {
      returns: interop.types.void,
      params: [interop.types.id]
    }
  };
  return MapPanHandlerImpl;
}(NSObject);

var MapSwipeHandlerImpl = function (_super) {
  __extends(MapSwipeHandlerImpl, _super);

  function MapSwipeHandlerImpl() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  MapSwipeHandlerImpl.initWithOwnerAndListenerForMap = function (owner, listener, mapView) {
    var handler = MapSwipeHandlerImpl.new();
    handler._owner = owner;
    handler._listener = listener;
    handler._mapView = mapView;
    return handler;
  };

  MapSwipeHandlerImpl.prototype.swipe = function (recognizer) {
    var swipePoint = recognizer.locationInView(this._mapView);

    var swipeCoordinate = this._mapView.convertPointToCoordinateFromView(swipePoint, this._mapView);

    this._listener({
      lat: swipeCoordinate.latitude,
      lng: swipeCoordinate.longitude
    });
  };

  MapSwipeHandlerImpl.ObjCExposedMethods = {
    "swipe": {
      returns: interop.types.void,
      params: [interop.types.id]
    }
  };
  return MapSwipeHandlerImpl;
}(NSObject);

/***/ }),

/***/ "../node_modules/vue-loader/lib/runtime/componentNormalizer.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return normalizeComponent; });
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent (
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier, /* server only */
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () { injectStyles.call(this, this.$root.$options.shadowRoot) }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functioal component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}


/***/ }),

/***/ "../node_modules/vuex/dist/vuex.esm.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Store", function() { return Store; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "install", function() { return install; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapState", function() { return mapState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapMutations", function() { return mapMutations; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapGetters", function() { return mapGetters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapActions", function() { return mapActions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createNamespacedHelpers", function() { return createNamespacedHelpers; });
/**
 * vuex v3.1.0
 * (c) 2019 Evan You
 * @license MIT
 */
function applyMixin(Vue) {
  var version = Number(Vue.version.split('.')[0]);

  if (version >= 2) {
    Vue.mixin({
      beforeCreate: vuexInit
    });
  } else {
    // override init and inject vuex init procedure
    // for 1.x backwards compatibility.
    var _init = Vue.prototype._init;

    Vue.prototype._init = function (options) {
      if (options === void 0) options = {};
      options.init = options.init ? [vuexInit].concat(options.init) : vuexInit;

      _init.call(this, options);
    };
  }
  /**
   * Vuex init hook, injected into each instances init hooks list.
   */


  function vuexInit() {
    var options = this.$options; // store injection

    if (options.store) {
      this.$store = typeof options.store === 'function' ? options.store() : options.store;
    } else if (options.parent && options.parent.$store) {
      this.$store = options.parent.$store;
    }
  }
}

var devtoolHook = typeof window !== 'undefined' && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

function devtoolPlugin(store) {
  if (!devtoolHook) {
    return;
  }

  store._devtoolHook = devtoolHook;
  devtoolHook.emit('vuex:init', store);
  devtoolHook.on('vuex:travel-to-state', function (targetState) {
    store.replaceState(targetState);
  });
  store.subscribe(function (mutation, state) {
    devtoolHook.emit('vuex:mutation', mutation, state);
  });
}
/**
 * Get the first item that pass the test
 * by second argument function
 *
 * @param {Array} list
 * @param {Function} f
 * @return {*}
 */

/**
 * forEach for object
 */


function forEachValue(obj, fn) {
  Object.keys(obj).forEach(function (key) {
    return fn(obj[key], key);
  });
}

function isObject(obj) {
  return obj !== null && typeof obj === 'object';
}

function isPromise(val) {
  return val && typeof val.then === 'function';
}

function assert(condition, msg) {
  if (!condition) {
    throw new Error("[vuex] " + msg);
  }
} // Base data struct for store's module, package with some attribute and method


var Module = function Module(rawModule, runtime) {
  this.runtime = runtime; // Store some children item

  this._children = Object.create(null); // Store the origin module object which passed by programmer

  this._rawModule = rawModule;
  var rawState = rawModule.state; // Store the origin module's state

  this.state = (typeof rawState === 'function' ? rawState() : rawState) || {};
};

var prototypeAccessors = {
  namespaced: {
    configurable: true
  }
};

prototypeAccessors.namespaced.get = function () {
  return !!this._rawModule.namespaced;
};

Module.prototype.addChild = function addChild(key, module) {
  this._children[key] = module;
};

Module.prototype.removeChild = function removeChild(key) {
  delete this._children[key];
};

Module.prototype.getChild = function getChild(key) {
  return this._children[key];
};

Module.prototype.update = function update(rawModule) {
  this._rawModule.namespaced = rawModule.namespaced;

  if (rawModule.actions) {
    this._rawModule.actions = rawModule.actions;
  }

  if (rawModule.mutations) {
    this._rawModule.mutations = rawModule.mutations;
  }

  if (rawModule.getters) {
    this._rawModule.getters = rawModule.getters;
  }
};

Module.prototype.forEachChild = function forEachChild(fn) {
  forEachValue(this._children, fn);
};

Module.prototype.forEachGetter = function forEachGetter(fn) {
  if (this._rawModule.getters) {
    forEachValue(this._rawModule.getters, fn);
  }
};

Module.prototype.forEachAction = function forEachAction(fn) {
  if (this._rawModule.actions) {
    forEachValue(this._rawModule.actions, fn);
  }
};

Module.prototype.forEachMutation = function forEachMutation(fn) {
  if (this._rawModule.mutations) {
    forEachValue(this._rawModule.mutations, fn);
  }
};

Object.defineProperties(Module.prototype, prototypeAccessors);

var ModuleCollection = function ModuleCollection(rawRootModule) {
  // register root module (Vuex.Store options)
  this.register([], rawRootModule, false);
};

ModuleCollection.prototype.get = function get(path) {
  return path.reduce(function (module, key) {
    return module.getChild(key);
  }, this.root);
};

ModuleCollection.prototype.getNamespace = function getNamespace(path) {
  var module = this.root;
  return path.reduce(function (namespace, key) {
    module = module.getChild(key);
    return namespace + (module.namespaced ? key + '/' : '');
  }, '');
};

ModuleCollection.prototype.update = function update$1(rawRootModule) {
  update([], this.root, rawRootModule);
};

ModuleCollection.prototype.register = function register(path, rawModule, runtime) {
  var this$1 = this;
  if (runtime === void 0) runtime = true;

  if (true) {
    assertRawModule(path, rawModule);
  }

  var newModule = new Module(rawModule, runtime);

  if (path.length === 0) {
    this.root = newModule;
  } else {
    var parent = this.get(path.slice(0, -1));
    parent.addChild(path[path.length - 1], newModule);
  } // register nested modules


  if (rawModule.modules) {
    forEachValue(rawModule.modules, function (rawChildModule, key) {
      this$1.register(path.concat(key), rawChildModule, runtime);
    });
  }
};

ModuleCollection.prototype.unregister = function unregister(path) {
  var parent = this.get(path.slice(0, -1));
  var key = path[path.length - 1];

  if (!parent.getChild(key).runtime) {
    return;
  }

  parent.removeChild(key);
};

function update(path, targetModule, newModule) {
  if (true) {
    assertRawModule(path, newModule);
  } // update target module


  targetModule.update(newModule); // update nested modules

  if (newModule.modules) {
    for (var key in newModule.modules) {
      if (!targetModule.getChild(key)) {
        if (true) {
          console.warn("[vuex] trying to add a new module '" + key + "' on hot reloading, " + 'manual reload is needed');
        }

        return;
      }

      update(path.concat(key), targetModule.getChild(key), newModule.modules[key]);
    }
  }
}

var functionAssert = {
  assert: function assert(value) {
    return typeof value === 'function';
  },
  expected: 'function'
};
var objectAssert = {
  assert: function assert(value) {
    return typeof value === 'function' || typeof value === 'object' && typeof value.handler === 'function';
  },
  expected: 'function or object with "handler" function'
};
var assertTypes = {
  getters: functionAssert,
  mutations: functionAssert,
  actions: objectAssert
};

function assertRawModule(path, rawModule) {
  Object.keys(assertTypes).forEach(function (key) {
    if (!rawModule[key]) {
      return;
    }

    var assertOptions = assertTypes[key];
    forEachValue(rawModule[key], function (value, type) {
      assert(assertOptions.assert(value), makeAssertionMessage(path, key, type, value, assertOptions.expected));
    });
  });
}

function makeAssertionMessage(path, key, type, value, expected) {
  var buf = key + " should be " + expected + " but \"" + key + "." + type + "\"";

  if (path.length > 0) {
    buf += " in module \"" + path.join('.') + "\"";
  }

  buf += " is " + JSON.stringify(value) + ".";
  return buf;
}

var Vue; // bind on install

var Store = function Store(options) {
  var this$1 = this;
  if (options === void 0) options = {}; // Auto install if it is not done yet and `window` has `Vue`.
  // To allow users to avoid auto-installation in some cases,
  // this code should be placed here. See #731

  if (!Vue && typeof window !== 'undefined' && window.Vue) {
    install(window.Vue);
  }

  if (true) {
    assert(Vue, "must call Vue.use(Vuex) before creating a store instance.");
    assert(typeof Promise !== 'undefined', "vuex requires a Promise polyfill in this browser.");
    assert(this instanceof Store, "store must be called with the new operator.");
  }

  var plugins = options.plugins;
  if (plugins === void 0) plugins = [];
  var strict = options.strict;
  if (strict === void 0) strict = false; // store internal state

  this._committing = false;
  this._actions = Object.create(null);
  this._actionSubscribers = [];
  this._mutations = Object.create(null);
  this._wrappedGetters = Object.create(null);
  this._modules = new ModuleCollection(options);
  this._modulesNamespaceMap = Object.create(null);
  this._subscribers = [];
  this._watcherVM = new Vue(); // bind commit and dispatch to self

  var store = this;
  var ref = this;
  var dispatch = ref.dispatch;
  var commit = ref.commit;

  this.dispatch = function boundDispatch(type, payload) {
    return dispatch.call(store, type, payload);
  };

  this.commit = function boundCommit(type, payload, options) {
    return commit.call(store, type, payload, options);
  }; // strict mode


  this.strict = strict;
  var state = this._modules.root.state; // init root module.
  // this also recursively registers all sub-modules
  // and collects all module getters inside this._wrappedGetters

  installModule(this, state, [], this._modules.root); // initialize the store vm, which is responsible for the reactivity
  // (also registers _wrappedGetters as computed properties)

  resetStoreVM(this, state); // apply plugins

  plugins.forEach(function (plugin) {
    return plugin(this$1);
  });
  var useDevtools = options.devtools !== undefined ? options.devtools : Vue.config.devtools;

  if (useDevtools) {
    devtoolPlugin(this);
  }
};

var prototypeAccessors$1 = {
  state: {
    configurable: true
  }
};

prototypeAccessors$1.state.get = function () {
  return this._vm._data.$$state;
};

prototypeAccessors$1.state.set = function (v) {
  if (true) {
    assert(false, "use store.replaceState() to explicit replace store state.");
  }
};

Store.prototype.commit = function commit(_type, _payload, _options) {
  var this$1 = this; // check object-style commit

  var ref = unifyObjectStyle(_type, _payload, _options);
  var type = ref.type;
  var payload = ref.payload;
  var options = ref.options;
  var mutation = {
    type: type,
    payload: payload
  };
  var entry = this._mutations[type];

  if (!entry) {
    if (true) {
      console.error("[vuex] unknown mutation type: " + type);
    }

    return;
  }

  this._withCommit(function () {
    entry.forEach(function commitIterator(handler) {
      handler(payload);
    });
  });

  this._subscribers.forEach(function (sub) {
    return sub(mutation, this$1.state);
  });

  if ( true && options && options.silent) {
    console.warn("[vuex] mutation type: " + type + ". Silent option has been removed. " + 'Use the filter functionality in the vue-devtools');
  }
};

Store.prototype.dispatch = function dispatch(_type, _payload) {
  var this$1 = this; // check object-style dispatch

  var ref = unifyObjectStyle(_type, _payload);
  var type = ref.type;
  var payload = ref.payload;
  var action = {
    type: type,
    payload: payload
  };
  var entry = this._actions[type];

  if (!entry) {
    if (true) {
      console.error("[vuex] unknown action type: " + type);
    }

    return;
  }

  try {
    this._actionSubscribers.filter(function (sub) {
      return sub.before;
    }).forEach(function (sub) {
      return sub.before(action, this$1.state);
    });
  } catch (e) {
    if (true) {
      console.warn("[vuex] error in before action subscribers: ");
      console.error(e);
    }
  }

  var result = entry.length > 1 ? Promise.all(entry.map(function (handler) {
    return handler(payload);
  })) : entry[0](payload);
  return result.then(function (res) {
    try {
      this$1._actionSubscribers.filter(function (sub) {
        return sub.after;
      }).forEach(function (sub) {
        return sub.after(action, this$1.state);
      });
    } catch (e) {
      if (true) {
        console.warn("[vuex] error in after action subscribers: ");
        console.error(e);
      }
    }

    return res;
  });
};

Store.prototype.subscribe = function subscribe(fn) {
  return genericSubscribe(fn, this._subscribers);
};

Store.prototype.subscribeAction = function subscribeAction(fn) {
  var subs = typeof fn === 'function' ? {
    before: fn
  } : fn;
  return genericSubscribe(subs, this._actionSubscribers);
};

Store.prototype.watch = function watch(getter, cb, options) {
  var this$1 = this;

  if (true) {
    assert(typeof getter === 'function', "store.watch only accepts a function.");
  }

  return this._watcherVM.$watch(function () {
    return getter(this$1.state, this$1.getters);
  }, cb, options);
};

Store.prototype.replaceState = function replaceState(state) {
  var this$1 = this;

  this._withCommit(function () {
    this$1._vm._data.$$state = state;
  });
};

Store.prototype.registerModule = function registerModule(path, rawModule, options) {
  if (options === void 0) options = {};

  if (typeof path === 'string') {
    path = [path];
  }

  if (true) {
    assert(Array.isArray(path), "module path must be a string or an Array.");
    assert(path.length > 0, 'cannot register the root module by using registerModule.');
  }

  this._modules.register(path, rawModule);

  installModule(this, this.state, path, this._modules.get(path), options.preserveState); // reset store to update getters...

  resetStoreVM(this, this.state);
};

Store.prototype.unregisterModule = function unregisterModule(path) {
  var this$1 = this;

  if (typeof path === 'string') {
    path = [path];
  }

  if (true) {
    assert(Array.isArray(path), "module path must be a string or an Array.");
  }

  this._modules.unregister(path);

  this._withCommit(function () {
    var parentState = getNestedState(this$1.state, path.slice(0, -1));
    Vue.delete(parentState, path[path.length - 1]);
  });

  resetStore(this);
};

Store.prototype.hotUpdate = function hotUpdate(newOptions) {
  this._modules.update(newOptions);

  resetStore(this, true);
};

Store.prototype._withCommit = function _withCommit(fn) {
  var committing = this._committing;
  this._committing = true;
  fn();
  this._committing = committing;
};

Object.defineProperties(Store.prototype, prototypeAccessors$1);

function genericSubscribe(fn, subs) {
  if (subs.indexOf(fn) < 0) {
    subs.push(fn);
  }

  return function () {
    var i = subs.indexOf(fn);

    if (i > -1) {
      subs.splice(i, 1);
    }
  };
}

function resetStore(store, hot) {
  store._actions = Object.create(null);
  store._mutations = Object.create(null);
  store._wrappedGetters = Object.create(null);
  store._modulesNamespaceMap = Object.create(null);
  var state = store.state; // init all modules

  installModule(store, state, [], store._modules.root, true); // reset vm

  resetStoreVM(store, state, hot);
}

function resetStoreVM(store, state, hot) {
  var oldVm = store._vm; // bind store public getters

  store.getters = {};
  var wrappedGetters = store._wrappedGetters;
  var computed = {};
  forEachValue(wrappedGetters, function (fn, key) {
    // use computed to leverage its lazy-caching mechanism
    computed[key] = function () {
      return fn(store);
    };

    Object.defineProperty(store.getters, key, {
      get: function get() {
        return store._vm[key];
      },
      enumerable: true // for local getters

    });
  }); // use a Vue instance to store the state tree
  // suppress warnings just in case the user has added
  // some funky global mixins

  var silent = Vue.config.silent;
  Vue.config.silent = true;
  store._vm = new Vue({
    data: {
      $$state: state
    },
    computed: computed
  });
  Vue.config.silent = silent; // enable strict mode for new vm

  if (store.strict) {
    enableStrictMode(store);
  }

  if (oldVm) {
    if (hot) {
      // dispatch changes in all subscribed watchers
      // to force getter re-evaluation for hot reloading.
      store._withCommit(function () {
        oldVm._data.$$state = null;
      });
    }

    Vue.nextTick(function () {
      return oldVm.$destroy();
    });
  }
}

function installModule(store, rootState, path, module, hot) {
  var isRoot = !path.length;

  var namespace = store._modules.getNamespace(path); // register in namespace map


  if (module.namespaced) {
    store._modulesNamespaceMap[namespace] = module;
  } // set state


  if (!isRoot && !hot) {
    var parentState = getNestedState(rootState, path.slice(0, -1));
    var moduleName = path[path.length - 1];

    store._withCommit(function () {
      Vue.set(parentState, moduleName, module.state);
    });
  }

  var local = module.context = makeLocalContext(store, namespace, path);
  module.forEachMutation(function (mutation, key) {
    var namespacedType = namespace + key;
    registerMutation(store, namespacedType, mutation, local);
  });
  module.forEachAction(function (action, key) {
    var type = action.root ? key : namespace + key;
    var handler = action.handler || action;
    registerAction(store, type, handler, local);
  });
  module.forEachGetter(function (getter, key) {
    var namespacedType = namespace + key;
    registerGetter(store, namespacedType, getter, local);
  });
  module.forEachChild(function (child, key) {
    installModule(store, rootState, path.concat(key), child, hot);
  });
}
/**
 * make localized dispatch, commit, getters and state
 * if there is no namespace, just use root ones
 */


function makeLocalContext(store, namespace, path) {
  var noNamespace = namespace === '';
  var local = {
    dispatch: noNamespace ? store.dispatch : function (_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;

      if (!options || !options.root) {
        type = namespace + type;

        if ( true && !store._actions[type]) {
          console.error("[vuex] unknown local action type: " + args.type + ", global type: " + type);
          return;
        }
      }

      return store.dispatch(type, payload);
    },
    commit: noNamespace ? store.commit : function (_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;

      if (!options || !options.root) {
        type = namespace + type;

        if ( true && !store._mutations[type]) {
          console.error("[vuex] unknown local mutation type: " + args.type + ", global type: " + type);
          return;
        }
      }

      store.commit(type, payload, options);
    }
  }; // getters and state object must be gotten lazily
  // because they will be changed by vm update

  Object.defineProperties(local, {
    getters: {
      get: noNamespace ? function () {
        return store.getters;
      } : function () {
        return makeLocalGetters(store, namespace);
      }
    },
    state: {
      get: function get() {
        return getNestedState(store.state, path);
      }
    }
  });
  return local;
}

function makeLocalGetters(store, namespace) {
  var gettersProxy = {};
  var splitPos = namespace.length;
  Object.keys(store.getters).forEach(function (type) {
    // skip if the target getter is not match this namespace
    if (type.slice(0, splitPos) !== namespace) {
      return;
    } // extract local getter type


    var localType = type.slice(splitPos); // Add a port to the getters proxy.
    // Define as getter property because
    // we do not want to evaluate the getters in this time.

    Object.defineProperty(gettersProxy, localType, {
      get: function get() {
        return store.getters[type];
      },
      enumerable: true
    });
  });
  return gettersProxy;
}

function registerMutation(store, type, handler, local) {
  var entry = store._mutations[type] || (store._mutations[type] = []);
  entry.push(function wrappedMutationHandler(payload) {
    handler.call(store, local.state, payload);
  });
}

function registerAction(store, type, handler, local) {
  var entry = store._actions[type] || (store._actions[type] = []);
  entry.push(function wrappedActionHandler(payload, cb) {
    var res = handler.call(store, {
      dispatch: local.dispatch,
      commit: local.commit,
      getters: local.getters,
      state: local.state,
      rootGetters: store.getters,
      rootState: store.state
    }, payload, cb);

    if (!isPromise(res)) {
      res = Promise.resolve(res);
    }

    if (store._devtoolHook) {
      return res.catch(function (err) {
        store._devtoolHook.emit('vuex:error', err);

        throw err;
      });
    } else {
      return res;
    }
  });
}

function registerGetter(store, type, rawGetter, local) {
  if (store._wrappedGetters[type]) {
    if (true) {
      console.error("[vuex] duplicate getter key: " + type);
    }

    return;
  }

  store._wrappedGetters[type] = function wrappedGetter(store) {
    return rawGetter(local.state, // local state
    local.getters, // local getters
    store.state, // root state
    store.getters // root getters
    );
  };
}

function enableStrictMode(store) {
  store._vm.$watch(function () {
    return this._data.$$state;
  }, function () {
    if (true) {
      assert(store._committing, "do not mutate vuex store state outside mutation handlers.");
    }
  }, {
    deep: true,
    sync: true
  });
}

function getNestedState(state, path) {
  return path.length ? path.reduce(function (state, key) {
    return state[key];
  }, state) : state;
}

function unifyObjectStyle(type, payload, options) {
  if (isObject(type) && type.type) {
    options = payload;
    payload = type;
    type = type.type;
  }

  if (true) {
    assert(typeof type === 'string', "expects string as the type, but found " + typeof type + ".");
  }

  return {
    type: type,
    payload: payload,
    options: options
  };
}

function install(_Vue) {
  if (Vue && _Vue === Vue) {
    if (true) {
      console.error('[vuex] already installed. Vue.use(Vuex) should be called only once.');
    }

    return;
  }

  Vue = _Vue;
  applyMixin(Vue);
}
/**
 * Reduce the code which written in Vue.js for getting the state.
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} states # Object's item can be a function which accept state and getters for param, you can do something for state and getters in it.
 * @param {Object}
 */


var mapState = normalizeNamespace(function (namespace, states) {
  var res = {};
  normalizeMap(states).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedState() {
      var state = this.$store.state;
      var getters = this.$store.getters;

      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapState', namespace);

        if (!module) {
          return;
        }

        state = module.context.state;
        getters = module.context.getters;
      }

      return typeof val === 'function' ? val.call(this, state, getters) : state[val];
    }; // mark vuex getter for devtools


    res[key].vuex = true;
  });
  return res;
});
/**
 * Reduce the code which written in Vue.js for committing the mutation
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} mutations # Object's item can be a function which accept `commit` function as the first param, it can accept anthor params. You can commit mutation and do any other things in this function. specially, You need to pass anthor params from the mapped function.
 * @return {Object}
 */

var mapMutations = normalizeNamespace(function (namespace, mutations) {
  var res = {};
  normalizeMap(mutations).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedMutation() {
      var args = [],
          len = arguments.length;

      while (len--) args[len] = arguments[len]; // Get the commit method from store


      var commit = this.$store.commit;

      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapMutations', namespace);

        if (!module) {
          return;
        }

        commit = module.context.commit;
      }

      return typeof val === 'function' ? val.apply(this, [commit].concat(args)) : commit.apply(this.$store, [val].concat(args));
    };
  });
  return res;
});
/**
 * Reduce the code which written in Vue.js for getting the getters
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} getters
 * @return {Object}
 */

var mapGetters = normalizeNamespace(function (namespace, getters) {
  var res = {};
  normalizeMap(getters).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val; // The namespace has been mutated by normalizeNamespace

    val = namespace + val;

    res[key] = function mappedGetter() {
      if (namespace && !getModuleByNamespace(this.$store, 'mapGetters', namespace)) {
        return;
      }

      if ( true && !(val in this.$store.getters)) {
        console.error("[vuex] unknown getter: " + val);
        return;
      }

      return this.$store.getters[val];
    }; // mark vuex getter for devtools


    res[key].vuex = true;
  });
  return res;
});
/**
 * Reduce the code which written in Vue.js for dispatch the action
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} actions # Object's item can be a function which accept `dispatch` function as the first param, it can accept anthor params. You can dispatch action and do any other things in this function. specially, You need to pass anthor params from the mapped function.
 * @return {Object}
 */

var mapActions = normalizeNamespace(function (namespace, actions) {
  var res = {};
  normalizeMap(actions).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedAction() {
      var args = [],
          len = arguments.length;

      while (len--) args[len] = arguments[len]; // get dispatch function from store


      var dispatch = this.$store.dispatch;

      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapActions', namespace);

        if (!module) {
          return;
        }

        dispatch = module.context.dispatch;
      }

      return typeof val === 'function' ? val.apply(this, [dispatch].concat(args)) : dispatch.apply(this.$store, [val].concat(args));
    };
  });
  return res;
});
/**
 * Rebinding namespace param for mapXXX function in special scoped, and return them by simple object
 * @param {String} namespace
 * @return {Object}
 */

var createNamespacedHelpers = function createNamespacedHelpers(namespace) {
  return {
    mapState: mapState.bind(null, namespace),
    mapGetters: mapGetters.bind(null, namespace),
    mapMutations: mapMutations.bind(null, namespace),
    mapActions: mapActions.bind(null, namespace)
  };
};
/**
 * Normalize the map
 * normalizeMap([1, 2, 3]) => [ { key: 1, val: 1 }, { key: 2, val: 2 }, { key: 3, val: 3 } ]
 * normalizeMap({a: 1, b: 2, c: 3}) => [ { key: 'a', val: 1 }, { key: 'b', val: 2 }, { key: 'c', val: 3 } ]
 * @param {Array|Object} map
 * @return {Object}
 */


function normalizeMap(map) {
  return Array.isArray(map) ? map.map(function (key) {
    return {
      key: key,
      val: key
    };
  }) : Object.keys(map).map(function (key) {
    return {
      key: key,
      val: map[key]
    };
  });
}
/**
 * Return a function expect two param contains namespace and map. it will normalize the namespace and then the param's function will handle the new namespace and the map.
 * @param {Function} fn
 * @return {Function}
 */


function normalizeNamespace(fn) {
  return function (namespace, map) {
    if (typeof namespace !== 'string') {
      map = namespace;
      namespace = '';
    } else if (namespace.charAt(namespace.length - 1) !== '/') {
      namespace += '/';
    }

    return fn(namespace, map);
  };
}
/**
 * Search a special module from store by namespace. if module not exist, print error message.
 * @param {Object} store
 * @param {String} helper
 * @param {String} namespace
 * @return {Object}
 */


function getModuleByNamespace(store, helper, namespace) {
  var module = store._modulesNamespaceMap[namespace];

  if ( true && !module) {
    console.error("[vuex] module namespace not found in " + helper + "(): " + namespace);
  }

  return module;
}

var index_esm = {
  Store: Store,
  install: install,
  version: '3.1.0',
  mapState: mapState,
  mapMutations: mapMutations,
  mapGetters: mapGetters,
  mapActions: mapActions,
  createNamespacedHelpers: createNamespacedHelpers
};
/* harmony default export */ __webpack_exports__["default"] = (index_esm);


/***/ })

}]);